diff --git a/logic/src/main/java/pl/pwr/ludoSimulator/logic/Board.java b/logic/src/main/java/pl/pwr/ludoSimulator/logic/Board.java
index c72d50e..dc2fe87 100644
--- a/logic/src/main/java/pl/pwr/ludoSimulator/logic/Board.java
+++ b/logic/src/main/java/pl/pwr/ludoSimulator/logic/Board.java
@@ -4,6 +4,7 @@ import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.stream.Collectors;
 
 public class Board {
     private final List<Player> players;
@@ -21,18 +22,23 @@ public class Board {
     }
 
     public List<Player> getActivePlayers() {
-        List<Player> list = new ArrayList<>();
-        for (Player player : players) {
-            if (getPlayerPawns(player).getEndPawns().size() != 4) {
-                list.add(player);
-            }
-        }
-        return list;
+      return players.stream()
+          .filter(this::doesntHaveAllPawnsInHome)
+          .collect(Collectors.toList());
+
     }
-    public Board (List<Player> players) {
+
+    public boolean hasAnyActivePlayer() {
+      return getActivePlayers().size() > 1;
+    }
+  private boolean doesntHaveAllPawnsInHome(Player player) {
+    return getPlayerPawns(player).getEndPawns().size() != 4;
+  }
+
+  public Board (List<Player> players) {
         this.players =  players;
         for (Player player : players) {
             playersMap.put(player, new PlayerPawns());
         }
     }
-}
\ No newline at end of file
+}
diff --git a/logic/src/main/java/pl/pwr/ludoSimulator/logic/Player.java b/logic/src/main/java/pl/pwr/ludoSimulator/logic/Player.java
index 7f7d406..11ef1f8 100644
--- a/logic/src/main/java/pl/pwr/ludoSimulator/logic/Player.java
+++ b/logic/src/main/java/pl/pwr/ludoSimulator/logic/Player.java
@@ -21,4 +21,21 @@ public class Player  {
         this.startPosition = startPosition;
         this.endPosition = endPosition;
     }
-}
\ No newline at end of file
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o)
+      return true;
+    if (o == null || getClass() != o.getClass())
+      return false;
+
+    Player player = (Player) o;
+
+    return id == player.id;
+  }
+
+  @Override
+  public int hashCode() {
+    return id;
+  }
+}
diff --git a/logic/src/main/java/pl/pwr/ludoSimulator/logic/actions/KillPawnAction.java b/logic/src/main/java/pl/pwr/ludoSimulator/logic/actions/KillPawnAction.java
index beb863c..9c9b511 100644
--- a/logic/src/main/java/pl/pwr/ludoSimulator/logic/actions/KillPawnAction.java
+++ b/logic/src/main/java/pl/pwr/ludoSimulator/logic/actions/KillPawnAction.java
@@ -10,29 +10,43 @@ public class KillPawnAction implements Action {
         return getPawns(board, player, roll).size() != 0;
     }
 
-    private List<Pawn> getPawns(Board board, Player player, int roll) {
-        List<Integer> otherPlayersUsedPositions = new ArrayList<>();
-        List<Pawn> activePawnsWhichCanKill = new ArrayList<>();
-        for (Player currentPlayer : board.getPlayers()) {
-            if (currentPlayer.getId() != player.getId()) {
-                for (Pawn pawn : board.getPlayerPawns(currentPlayer).getActivePawns()) {
-                    otherPlayersUsedPositions.add(pawn.getPosition());
-                }
-            }
-        }
-        for (Pawn pawn : board.getPlayerPawns(player).getActivePawns()) {
-            if (otherPlayersUsedPositions.contains((pawn.getPosition() + roll) % 40)) {
-                if (pawn.getPosition() + roll < player.getEndPosition()) {
-                    activePawnsWhichCanKill.add(pawn);
-                } else if (pawn.getPosition() > player.getEndPosition()) {
-                    activePawnsWhichCanKill.add(pawn);
-                }
+    private List<Pawn> getPawns(Board board, Player actionPerformer, int roll) {
+
+      List<Integer> positionsOccupiedByAnotherPlayers = getPositionsOccupiedByAnotherPlayers(board, actionPerformer);
+
+      return findKillablePawns(board, actionPerformer, roll, positionsOccupiedByAnotherPlayers);
+    }
+
+  private List<Pawn> findKillablePawns(Board board, Player actionPerformer, int roll, List<Integer> positionsOccupiedByAnotherPlayers) {
+    List<Pawn> activePawnsWhichCanKill = new ArrayList<>();
+    List<Pawn> actionPerformerPawns = board.getPlayerPawns(actionPerformer).getActivePawns();
+
+    for (Pawn pawn : actionPerformerPawns) {
+          if (positionsOccupiedByAnotherPlayers.contains((pawn.getPosition() + roll) % 40)) {
+              if (pawn.getPosition() + roll < actionPerformer.getEndPosition()) {
+                  activePawnsWhichCanKill.add(pawn);
+              } else if (pawn.getPosition() > actionPerformer.getEndPosition()) {
+                  activePawnsWhichCanKill.add(pawn);
+              }
+          }
+      }
+
+    return activePawnsWhichCanKill;
+  }
+
+  private List<Integer> getPositionsOccupiedByAnotherPlayers(Board board, Player actionPerformer) {
+    List<Integer> otherPlayersUsedPositions = new ArrayList<>();
+    for (Player player : board.getPlayers()) {
+        if (!player.equals(actionPerformer)) {
+            for (Pawn pawn : board.getPlayerPawns(player).getActivePawns()) {
+                otherPlayersUsedPositions.add(pawn.getPosition());
             }
         }
-        return activePawnsWhichCanKill;
     }
+    return otherPlayersUsedPositions;
+  }
 
-    @Override
+  @Override
     public Board execute(Board board, Player player, int roll) {
         int endPosition = player.getEndPosition();
         List<Pawn> pawns = getPawns(board, player, roll);
diff --git a/logic/src/main/java/pl/pwr/ludoSimulator/logic/actions/MoveActivePawnAction.java b/logic/src/main/java/pl/pwr/ludoSimulator/logic/actions/MoveActivePawnAction.java
index 735065c..bfd66a9 100644
--- a/logic/src/main/java/pl/pwr/ludoSimulator/logic/actions/MoveActivePawnAction.java
+++ b/logic/src/main/java/pl/pwr/ludoSimulator/logic/actions/MoveActivePawnAction.java
@@ -49,8 +49,11 @@ public class MoveActivePawnAction implements Action {
     @Override
     public Board execute(Board board, Player player, int roll) {
         int endPosition = player.getEndPosition();
+
         List<Integer> usedEndPositions = getUsedEndPositions(board, player);
         List<Pawn> pawns = getPawns(board, player, roll);
+
+
         if (pawns.size() != 0) {
             Pawn pawn = pawns.get(0);
         if (pawn.getPosition() + roll < endPosition || pawn.getPosition() > endPosition) {
diff --git a/simulation/src/main/java/pl/pwr/ludoSimulator/simulation/Simulation.java b/simulation/src/main/java/pl/pwr/ludoSimulator/simulation/Simulation.java
index d93eb50..fd94863 100644
--- a/simulation/src/main/java/pl/pwr/ludoSimulator/simulation/Simulation.java
+++ b/simulation/src/main/java/pl/pwr/ludoSimulator/simulation/Simulation.java
@@ -22,24 +22,29 @@ public class Simulation {
     public void start () {
         Display display = new Display(board);
         display.display();
-        while (board.getActivePlayers().size() > 1) {
+        while (board.hasAnyActivePlayer()) {
             for (Player player : board.getActivePlayers()) {
                 int roll;
                 do {
                     roll = Dice.roll();
-                    List<Action> possibleActions = findPossibleActions(board, player, roll);
-                    boolean wasActionAccomplished =  (possibleActions.size() != 0);
-                    if (wasActionAccomplished) {
-                        afterActionAccomplished(board, player, roll, possibleActions);
-                        simulationCallback.callbackAfterMove();
-                    }
+                    executeRandomAction(player, roll);
                 } while (roll == 6);
             }
             simulationCallback.callbackAfterRound();
         }
         simulationCallback.callbackAfterEnd();
     }
-    private List<Action> findPossibleActions (Board board, Player player, int roll) {
+
+  private void executeRandomAction(Player player, int roll) {
+    List<Action> possibleActions = findPossibleActions(board, player, roll);
+    boolean thereAreAnyActions =  (possibleActions.size() != 0);
+    if (thereAreAnyActions) {
+        executeRandomAction(board, player, roll, possibleActions);
+        simulationCallback.callbackAfterMove();
+    }
+  }
+
+  private List<Action> findPossibleActions (Board board, Player player, int roll) {
         List <Action> possibleActions = new ArrayList<>();
         for (Action action : actions) {
             if (action.isPossible(board, player, roll))
@@ -47,7 +52,7 @@ public class Simulation {
         }
         return possibleActions;
     }
-    private void afterActionAccomplished (Board board, Player player, int roll, List<Action> possibleActions) {
+    private void executeRandomAction(Board board, Player player, int roll, List<Action> possibleActions) {
         int actionToExecute = random(possibleActions.size());
         possibleActions.get(actionToExecute).execute(board, player, roll);
     }
